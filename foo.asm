# MIPS CODE GENERATED BY CS370

.data

_l0: .asciiz 	 "hello\n"  # string
_l1: .asciiz 	 "world\n"  # string
_l2: .asciiz 	 "\n"  # string
_l3: .asciiz 	 "Type in a number: "  # string
_l4: .asciiz 	 "You typed: "  # string
_l5: .asciiz 	 "\n"  # string
_l6: .asciiz 	 "\n"  # string
_l7: .asciiz 	 "\n"  # string
_l8: .asciiz 	 "\n"  # string
_l9: .asciiz 	 "if"  # string
_l10: .asciiz 	 "else"  # string
_l11: .asciiz 	 "ppp"  # string
.align 2
x: .space 4 # global variable 
a: .space 4 # global variable 
b: .space 400 # global variable 
c: .space 40 # global variable 
.text


.globl main

yo:			# function definition
	move $a1, $sp		# Activation Record carve out copy of function
	subi $a1, $a1, 24		# Activation Record carve out copy of function
	sw $ra, ($a1)		# Store return address
	sw $sp 4($a1)		# store the old stack pointer
	move $sp, $a1		# make SP the currenr activaton record

	sw $t0, 8($sp)		# loads formal
	li $a0, 0		# Return is set to 0
	li $a0, 100		# expression is constant
	sw $a0, 12($sp)		# Store expr's RHS temporairly
	move $a0, $sp		# Store a copy of SP
	add $a0, $a0, 8		# add SP and offset for variable address
	lw $a0, ($a0)		# Expression is a Var
	lw $a1, 12($sp)		# Store expr's RHS temporairly
	slt $a0, $a0, $a1		# less than operator

	beq $0, $a0 _l13		# if false go to else

	li $a0, 0		# return has no expression
	li $a0, 2		# expression is constant
	sw $a0, 16($sp)		# Store expr's RHS temporairly
	move $a0, $sp		# Store a copy of SP
	add $a0, $a0, 8		# add SP and offset for variable address
	lw $a0, ($a0)		# Expression is a Var
	lw $a1, 16($sp)		# Store expr's RHS temporairly
	mul $a0, $a0, $a1		# Times operator
	mflo $a0		# low operator

	sw $a0, 20($sp)		# store call args
	lw $t0 20($sp)		# get the stored arg
	jal yo		# jump to function label args
	lw $ra ($sp)		# Restore old ebviorment RA
	lw $sp 4($sp)		# return from function store SP
	beq $ra, $0, _l14		# Break if return is in main
	jr $ra		# return to call
_l14:			# EXIT main

	j _l12		# jump to out after IF

_l13:			# else
	li $a0, 0		# return has no expression
	move $a0, $sp		# Store a copy of SP
	add $a0, $a0, 8		# add SP and offset for variable address
	lw $a0, ($a0)		# Expression is a Var
	lw $ra ($sp)		# Restore old ebviorment RA
	lw $sp 4($sp)		# return from function store SP
	beq $ra, $0, _l15		# Break if return is in main
	jr $ra		# return to call
_l15:			# EXIT main

_l12:			# Out label
	lw $ra ($sp)		# Restore old ebviorment RA
	lw $sp 4($sp)		# return from function store SP

	jr $ra		# Return to caller
yoo:			# function definition
	move $a1, $sp		# Activation Record carve out copy of function
	subi $a1, $a1, 40		# Activation Record carve out copy of function
	sw $ra, ($a1)		# Store return address
	sw $sp 4($a1)		# store the old stack pointer
	move $sp, $a1		# make SP the currenr activaton record

	sw $t0, 8($sp)		# loads formal
	sw $t1, 12($sp)		# loads formal
	sw $t2, 16($sp)		# loads formal
	sw $t3, 20($sp)		# loads formal
	sw $t4, 24($sp)		# loads formal
	sw $t5, 28($sp)		# loads formal
	sw $t6, 32($sp)		# loads formal
	sw $t7, 36($sp)		# loads formal
	li $a0, 0		# Return is set to 0
	la $a0, _l11		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	lw $ra ($sp)		# Restore old ebviorment RA
	lw $sp 4($sp)		# return from function store SP

	jr $ra		# Return to caller
main:			# function definition
	move $a1, $sp		# Activation Record carve out copy of function
	subi $a1, $a1, 36		# Activation Record carve out copy of function
	sw $ra, ($a1)		# Store return address
	sw $sp 4($a1)		# store the old stack pointer
	move $sp, $a1		# make SP the currenr activaton record

	li $a0, 0		# Return is set to 0
	la $a0, _l0		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	la $a0, _l1		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	li $a0, 2		# expression is constant
	li $v0, 1		# About to print a number
	syscall		# Call write a number

	la $a0, _l2		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	la $a0, _l3		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	la $a0 x		# EMIT var global varible
	li $v0, 5		# About to read in value
	syscall		# read in value $v0 now has readin value
	sw $v0, ($a0)		# store read in value to memory

	la $a0, _l4		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	la $a0 x		# EMIT var global varible
	lw $a0, ($a0)		# Expression is a Var
	li $v0, 1		# About to print a number
	syscall		# Call write a number

	la $a0, _l5		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	li $a0, 0		# expression is constant
	sw $a0, 8($sp)		# Store assignment in RHS
	la $a0 a		# EMIT var global varible
	lw $a1, 8($sp)		# get assignment in RHS
	sw $a1, ($a0)		# Assign expression to var

	li $a0, 10		# expression is constant
	sw $a0, 12($sp)		# Store assignment in RHS
	la $a0 x		# EMIT var global varible
	lw $a1, 12($sp)		# get assignment in RHS
	sw $a1, ($a0)		# Assign expression to var

	la $a0 x		# EMIT var global varible
	lw $a0, ($a0)		# Expression is a Var
	sw $a0, 16($sp)		# store call args
	lw $t0 16($sp)		# get the stored arg
	jal yo		# jump to function label args
	sw $a0, 20($sp)		# Store assignment in RHS
	la $a0 x		# EMIT var global varible
	lw $a1, 20($sp)		# get assignment in RHS
	sw $a1, ($a0)		# Assign expression to var

	li $a0, 10		# expression is constant
	sw $a0, 24($sp)		# Store assignment in RHS
	li $a0, 100		# expression is constant
	sll $a1 $a0, 2		# get offset for element in array
	la $a0 b		# EMIT var global varible
	add $a0, $a0, $a1		# add the additonal offset
	lw $a1, 24($sp)		# get assignment in RHS
	sw $a1, ($a0)		# Assign expression to var

	li $a0, 0		# expression is constant
	sll $a1 $a0, 2		# get offset for element in array
	la $a0 b		# EMIT var global varible
	add $a0, $a0, $a1		# add the additonal offset
	lw $a0, ($a0)		# Expression is a Var
	li $v0, 1		# About to print a number
	syscall		# Call write a number

	la $a0, _l6		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	li $a0, 100		# expression is constant
	sll $a1 $a0, 2		# get offset for element in array
	la $a0 b		# EMIT var global varible
	add $a0, $a0, $a1		# add the additonal offset
	lw $a0, ($a0)		# Expression is a Var
	li $v0, 1		# About to print a number
	syscall		# Call write a number

	la $a0, _l7		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	la $a0 x		# EMIT var global varible
	lw $a0, ($a0)		# Expression is a Var
	li $v0, 1		# About to print a number
	syscall		# Call write a number

	la $a0, _l8		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	li $a0, 2		# expression is constant
	sw $a0, 28($sp)		# Store assignment in RHS
	la $a0 a		# EMIT var global varible
	lw $a1, 28($sp)		# get assignment in RHS
	sw $a1, ($a0)		# Assign expression to var

	la $a0 x		# EMIT var global varible
	lw $a0, ($a0)		# Expression is a Var
	sw $a0, 32($sp)		# Store expr's RHS temporairly
	la $a0 a		# EMIT var global varible
	lw $a0, ($a0)		# Expression is a Var
	lw $a1, 32($sp)		# Store expr's RHS temporairly
	slt $a0, $a1, $a0		# greater than operator

	beq $0, $a0 _l17		# if false go to else

	la $a0, _l9		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

	j _l16		# jump to out after IF

_l17:			# else
	la $a0, _l10		# the string address
	li $v0, 4		# About to print a string
	syscall		# Call write string

_l16:			# Out label
	li $a0, 0		# return has no expression
	li $a0, 1		# expression is constant
	lw $ra ($sp)		# Restore old ebviorment RA
	lw $sp 4($sp)		# return from function store SP
	beq $ra, $0, _l18		# Break if return is in main
	jr $ra		# return to call
_l18:			# EXIT main

	lw $ra ($sp)		# Restore old ebviorment RA
	lw $sp 4($sp)		# return from function store SP

	li $v0, 10		# Exit from main, we are done
	syscall		# exit everything
